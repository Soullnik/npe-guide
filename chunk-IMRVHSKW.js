import{a as C,b as X}from"./chunk-YQJKR3JJ.js";import{a as w,b as K}from"./chunk-VSKATVDD.js";import{a as R,b as q}from"./chunk-EELPIEAV.js";import{k as d,l as H}from"./chunk-RIAPI5OR.js";import{n as F,o as Z}from"./chunk-C2NDYXG7.js";import{e as E,f as j}from"./chunk-JB6X5724.js";import{a as B,b as G,f as T,u as O}from"./chunk-J2REHNP7.js";import{P as v,Q as Y,n as x,o as N}from"./chunk-WFRBO4E6.js";import{A,v as g}from"./chunk-DYR6BFEB.js";import{a as M,d as k}from"./chunk-A2QYPOYP.js";import{a as b,b as W}from"./chunk-MEUTOEEX.js";import{a as S,b as z}from"./chunk-RR3YIVG4.js";import{a as y,e as _}from"./chunk-FAF55DAL.js";var c,P=_(()=>{"use strict";G();O();j();k();Z();K();W();Y();X();N();c=class p{get options(){return this._options}get shaderPath(){return this._shaderPath}constructor(e,t,i,r={}){if(this._bindings={},this._samplers={},this._contextIsDirty=!1,this.fastMode=!1,this.onCompiled=null,this.onError=null,this.triggerContextRebuild=!1,this.name=e,this._engine=t,this.uniqueId=w.UniqueId,t.enableGPUTimingMeasurements&&(this.gpuTimeInFrame=new C),!this._engine.getCaps().supportComputeShaders){b.Error("This engine does not support compute shaders!");return}if(!r.bindingsMapping){b.Error("You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!");return}this._context=t.createComputeContext(),this._shaderPath=i,this._options=y({bindingsMapping:{},defines:[],entryPoint:"main"},r)}getClassName(){return"ComputeShader"}setTexture(e,t,i=!0){let r=this._bindings[e];this._bindings[e]={type:i?0:4,object:t,indexInGroupEntries:r?.indexInGroupEntries},this._contextIsDirty||(this._contextIsDirty=!r||r.object!==t||r.type!==this._bindings[e].type)}setInternalTexture(e,t){let i=this._bindings[e];this._bindings[e]={type:8,object:t,indexInGroupEntries:i?.indexInGroupEntries},this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t||i.type!==this._bindings[e].type)}setStorageTexture(e,t){let i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t),this._bindings[e]={type:1,object:t,indexInGroupEntries:i?.indexInGroupEntries}}setExternalTexture(e,t){let i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t),this._bindings[e]={type:6,object:t,indexInGroupEntries:i?.indexInGroupEntries}}setVideoTexture(e,t){return t.externalTexture?(this.setExternalTexture(e,t.externalTexture),!0):!1}setUniformBuffer(e,t){let i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t),this._bindings[e]={type:p._BufferIsDataBuffer(t)?7:2,object:t,indexInGroupEntries:i?.indexInGroupEntries}}setStorageBuffer(e,t){let i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t),this._bindings[e]={type:p._BufferIsDataBuffer(t)?7:3,object:t,indexInGroupEntries:i?.indexInGroupEntries}}setTextureSampler(e,t){let i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||!t.compareSampler(i.object)),this._bindings[e]={type:5,object:t,indexInGroupEntries:i?.indexInGroupEntries}}isReady(){let e=this._effect;for(let s in this._bindings){let n=this._bindings[s],a=n.type,u=n.object;switch(a){case 0:case 4:case 1:{if(!u.isReady())return!1;break}case 6:{if(!u.isReady())return!1;break}}}let t=["#define "+this._options.entryPoint],i=this._shaderPath;if(this._options.defines)for(let s=0;s<this._options.defines.length;s++)t.push(this._options.defines[s]);let r=t.join(`
`);return this._cachedDefines!==r&&(this._cachedDefines=r,e=this._engine.createComputeEffect(i,{defines:r,entryPoint:this._options.entryPoint,onCompiled:this.onCompiled,onError:this.onError}),this._effect=e),!!e.isReady()}dispatch(e,t,i){return(!this.fastMode||this.triggerContextRebuild)&&!this._checkContext()?!1:(this._engine.computeDispatch(this._effect,this._context,this._bindings,e,t,i,this._options.bindingsMapping,this.gpuTimeInFrame),!0)}dispatchIndirect(e,t=0){if((!this.fastMode||this.triggerContextRebuild)&&!this._checkContext())return!1;let i=p._BufferIsDataBuffer(e)?e:e.getBuffer();return this._engine.computeDispatchIndirect(this._effect,this._context,this._bindings,i,t,this._options.bindingsMapping,this.gpuTimeInFrame),!0}_checkContext(){if(!this.isReady())return!1;for(let e in this._bindings){let t=this._bindings[e];if(!this._options.bindingsMapping[e])throw new Error("ComputeShader ('"+this.name+"'): No binding mapping has been provided for the property '"+e+"'");switch(t.type){case 0:{let i=this._samplers[e],r=t.object;(!i||!r._texture||!i.compareSampler(r._texture))&&(this._samplers[e]=new v().setParameters(r.wrapU,r.wrapV,r.wrapR,r.anisotropicFilteringLevel,r._texture.samplingMode,r._texture?._comparisonFunction),this._contextIsDirty=!0);break}case 6:{this._contextIsDirty=!0;break}case 2:{let i=t.object;i.getBuffer()!==t.buffer&&(t.buffer=i.getBuffer(),this._contextIsDirty=!0);break}}}return this._contextIsDirty&&(this.triggerContextRebuild=!1,this._contextIsDirty=!1,this._context.clear()),!0}async dispatchWhenReady(e,t,i,r=10){return await new Promise(s=>{x(()=>this.dispatch(e,t,i),s,void 0,r)})}serialize(){let e=E.Serialize(this);e.options=this._options,e.shaderPath=this._shaderPath,e.bindings={},e.textures={};for(let t in this._bindings){let i=this._bindings[t],r=i.object;switch(i.type){case 0:case 4:case 1:{let s=r.serialize();s&&(e.textures[t]=s,e.bindings[t]={type:i.type});break}case 8:case 2:break}}return e}static Parse(e,t,i){let r=E.Parse(()=>new p(e.name,t.getEngine(),e.shaderPath,e.options),e,t,i);for(let s in e.textures){let n=e.bindings[s],a=F.Parse(e.textures[s],t,i);n.type===0?r.setTexture(s,a):n.type===4?r.setTexture(s,a,!1):r.setStorageTexture(s,a)}return r}static _BufferIsDataBuffer(e){return e.underlyingResource!==void 0}};B([T()],c.prototype,"name",void 0);B([T()],c.prototype,"fastMode",void 0);M("BABYLON.ComputeShader",c)});var l,D=_(()=>{"use strict";l=class{constructor(e,t,i=3,r){this._engine=e,this._label=r,this._engine._storageBuffers.push(this),this._create(t,i)}_create(e,t){this._bufferSize=e,this._creationFlags=t,this._buffer=this._engine.createStorageBuffer(e,t,this._label)}_rebuild(){this._create(this._bufferSize,this._creationFlags)}getBuffer(){return this._buffer}clear(e,t){this._engine.clearStorageBuffer(this._buffer,e,t)}update(e,t,i){this._buffer&&this._engine.updateStorageBuffer(this._buffer,e,t,i)}async read(e,t,i,r){return await this._engine.readFromStorageBuffer(this._buffer,e,t,i,r)}dispose(){let e=this._engine._storageBuffers,t=e.indexOf(this);t!==-1&&(e[t]=e[e.length-1],e.pop()),this._engine._releaseBuffer(this._buffer),this._buffer=null}}});var L,$,U=_(()=>{"use strict";z();L="boundingInfoComputeShader",$=`struct Results {minX : atomic<i32>,
minY : atomic<i32>,
minZ : atomic<i32>,
maxX : atomic<i32>,
maxY : atomic<i32>,
maxZ : atomic<i32>,
dummy1 : i32,
dummy2 : i32,};fn floatToBits(value: f32)->i32 {return bitcast<i32>(value);}
fn bitsToFloat(value: i32)->f32 {return bitcast<f32>(value);}
fn atomicMinFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value>=oldValue) {break;}
if (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}
fn atomicMaxFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value<=oldValue) {break;}
if (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}
fn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>
{let offset=i32(index) *4; 
let m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}
const identity=mat4x4f(
vec4f(1.0,0.0,0.0,0.0),
vec4f(0.0,1.0,0.0,0.0),
vec4f(0.0,0.0,1.0,0.0),
vec4f(0.0,0.0,0.0,1.0)
);struct Settings {morphTargetTextureInfo: vec3f,
morphTargetCount: f32,
indexResult : u32,};@group(0) @binding(0) var<storage,read> positionBuffer : array<f32>;@group(0) @binding(1) var<storage,read_write> resultBuffer : array<Results>;@group(0) @binding(7) var<uniform> settings : Settings;
#if NUM_BONE_INFLUENCERS>0
@group(0) @binding(2) var boneSampler : texture_2d<f32>;@group(0) @binding(3) var<storage,read> indexBuffer : array<vec4f>;@group(0) @binding(4) var<storage,read> weightBuffer : array<vec4f>;
#if NUM_BONE_INFLUENCERS>4
@group(0) @binding(5) var<storage,read> indexExtraBuffer : array<vec4f>;@group(0) @binding(6) var<storage,read> weightExtraBuffer : array<vec4f>;
#endif
#endif
#ifdef MORPHTARGETS
@group(0) @binding(8) var morphTargets : texture_2d_array<f32>;@group(0) @binding(9) var<storage,read> morphTargetInfluences : array<f32>;@group(0) @binding(10) var<storage,read> morphTargetTextureIndices : array<f32>;
#endif
#ifdef MORPHTARGETS
fn readVector3FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec3f
{ 
let vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0).xyz;}
fn readVector4FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec4f
{ 
let vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0);}
#endif
@compute @workgroup_size(256,1,1)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {let index=global_id.x;if (index>=arrayLength(&positionBuffer)/3) {return;}
let position=vec3f(positionBuffer[index*3],positionBuffer[index*3+1],positionBuffer[index*3+2]);var finalWorld=identity;var positionUpdated=position;
#if NUM_BONE_INFLUENCERS>0
var influence : mat4x4<f32>;let matricesIndices=indexBuffer[index];let matricesWeights=weightBuffer[index];influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
let matricesIndicesExtra=indexExtraBuffer[index];let matricesWeightsExtra=weightExtraBuffer[index];influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.x)*matricesWeightsExtra.x;
#if NUM_BONE_INFLUENCERS>5
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.y)*matricesWeightsExtra.y;
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.z)*matricesWeightsExtra.z;
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.w)*matricesWeightsExtra.w;
#endif 
#endif 
finalWorld=finalWorld*influence;
#endif
#ifdef MORPHTARGETS
for (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (f32(i)>=settings.morphTargetCount) {break;}
positionUpdated=positionUpdated+(readVector3FromRawSampler(i,index)-position)*morphTargetInfluences[i];}
#endif
var worldPos=finalWorld*vec4f(positionUpdated.x,positionUpdated.y,positionUpdated.z,1.0);atomicMinFloat(&resultBuffer[settings.indexResult].minX,worldPos.x);atomicMinFloat(&resultBuffer[settings.indexResult].minY,worldPos.y);atomicMinFloat(&resultBuffer[settings.indexResult].minZ,worldPos.z);atomicMaxFloat(&resultBuffer[settings.indexResult].maxX,worldPos.x);atomicMaxFloat(&resultBuffer[settings.indexResult].maxY,worldPos.y);atomicMaxFloat(&resultBuffer[settings.indexResult].maxZ,worldPos.z);}
`;S.ShadersStoreWGSL[L]||(S.ShadersStoreWGSL[L]=$)});var V,J=_(()=>{P();D();H();A();q();U();N();V=class{constructor(e){this._computeShadersCache={},this._positionBuffers={},this._indexBuffers={},this._weightBuffers={},this._indexExtraBuffers={},this._weightExtraBuffers={},this._morphTargetInfluenceBuffers={},this._morphTargetTextureIndexBuffers={},this._ubos=[],this._uboIndex=0,this._processedMeshes=[],this._computeShaders=[],this._uniqueComputeShaders=new Set,this._resultBuffers=[],this._engine=e}_getComputeShader(e,t,i){let r,s=e.join(`
`);if(this._computeShadersCache[s])r=this._computeShadersCache[s];else{let n={positionBuffer:{group:0,binding:0},resultBuffer:{group:0,binding:1},settings:{group:0,binding:7}};t&&(n.boneSampler={group:0,binding:2},n.indexBuffer={group:0,binding:3},n.weightBuffer={group:0,binding:4},n.indexExtraBuffer={group:0,binding:5},n.weightExtraBuffer={group:0,binding:6}),i&&(n.morphTargets={group:0,binding:8},n.morphTargetInfluences={group:0,binding:9},n.morphTargetTextureIndices={group:0,binding:10}),r=new c(`boundingInfoCompute${t?"_bones":""}${i?"_morphs":""}`,this._engine,"boundingInfo",{bindingsMapping:n,defines:e}),this._computeShadersCache[s]=r}return r}_getUBO(){if(this._uboIndex>=this._ubos.length){let e=new R(this._engine);e.addFloat3("morphTargetTextureInfo",0,0,0),e.addUniform("morphTargetCount",1),e.addUniform("indexResult",1),this._ubos.push(e)}return this._ubos[this._uboIndex++]}_extractDataAndLink(e,t,i,r,s,n){let a,u=t.getTotalVertices();if(n[t.uniqueId])a=n[t.uniqueId];else{let o=t.getVertexBuffer(i)?.getFloatData(u);a=new l(this._engine,Float32Array.BYTES_PER_ELEMENT*u*r),a.update(o),n[t.uniqueId]=a}e.setStorageBuffer(s,a)}_prepareStorage(e,t,i,r,s,n){let a;r[i]?a=r[i]:(a=new l(this._engine,Float32Array.BYTES_PER_ELEMENT*s),r[i]=a),a.update(n),e.setStorageBuffer(t,a)}async processAsync(e){await this.registerMeshListAsync(e),this.processMeshList(),await this.fetchResultsForMeshListAsync()}registerMeshListAsync(e){this._disposeForMeshList(),Array.isArray(e)||(e=[e]);let t=0;for(let i=0;i<e.length;i++){let r=e[i];if(r.getTotalVertices()===0||!r.getVertexBuffer||!r.getVertexBuffer(d.PositionKind))continue;this._processedMeshes.push(r);let n=r.morphTargetManager;n&&n.supportsPositions&&(t=Math.max(t,n.numTargets))}for(let i=0;i<this._processedMeshes.length;i++){let r=this._processedMeshes[i],s=[""],n=!1;r&&r.useBones&&r.computeBonesUsingShaders&&r.skeleton&&(s.push("#define NUM_BONE_INFLUENCERS "+r.numBoneInfluencers),n=!0);let a=this._getComputeShader(s,n,!1);this._uniqueComputeShaders.add(a);let u=r.morphTargetManager;if(u&&u.supportsPositions){s=s.slice(),s.push("#define MORPHTARGETS"),s.push("#define NUM_MORPH_INFLUENCERS "+t);let h=this._getComputeShader(s,n,!0);this._uniqueComputeShaders.add(h),this._computeShaders.push([a,h])}else this._computeShaders.push([a,a]);let o=this._getUBO();o.updateUInt("indexResult",i),o.update()}return new Promise(i=>{x(()=>{let r=this._uniqueComputeShaders.keys();for(let s=r.next();s.done!==!0;s=r.next())if(!s.value.isReady())return!1;return!0},i)})}processMeshList(){if(this._processedMeshes.length===0)return;this._uboIndex=0;let e=8*this._processedMeshes.length,t=new Float32Array(e),i=new l(this._engine,Float32Array.BYTES_PER_ELEMENT*e);this._resultBuffers.push(i);for(let r=0;r<this._processedMeshes.length;r++)t[r*8+0]=Number.POSITIVE_INFINITY,t[r*8+1]=Number.POSITIVE_INFINITY,t[r*8+2]=Number.POSITIVE_INFINITY,t[r*8+3]=Number.NEGATIVE_INFINITY,t[r*8+4]=Number.NEGATIVE_INFINITY,t[r*8+5]=Number.NEGATIVE_INFINITY;i.update(t);for(let r=0;r<this._processedMeshes.length;r++){let s=this._processedMeshes[r],n=s.getTotalVertices(),[a,u]=this._computeShaders[r],o=s.morphTargetManager,h=o&&o.numInfluencers>0&&o.supportsPositions,f=h?u:a;if(this._extractDataAndLink(f,s,d.PositionKind,3,"positionBuffer",this._positionBuffers),s&&s.useBones&&s.computeBonesUsingShaders&&s.skeleton&&s.skeleton.useTextureToStoreBoneMatrices){this._extractDataAndLink(f,s,d.MatricesIndicesKind,4,"indexBuffer",this._indexBuffers),this._extractDataAndLink(f,s,d.MatricesWeightsKind,4,"weightBuffer",this._weightBuffers);let I=s.skeleton.getTransformMatrixTexture(s);f.setTexture("boneSampler",I,!1),s.numBoneInfluencers>4&&(this._extractDataAndLink(f,s,d.MatricesIndicesExtraKind,4,"indexExtraBuffer",this._indexExtraBuffers),this._extractDataAndLink(f,s,d.MatricesWeightsExtraKind,4,"weightExtraBuffer",this._weightExtraBuffers))}let m=this._getUBO();if(h){let I=o._targetStoreTexture;f.setTexture("morphTargets",I,!1),this._prepareStorage(f,"morphTargetInfluences",s.uniqueId,this._morphTargetInfluenceBuffers,o.numInfluencers,o.influences),this._prepareStorage(f,"morphTargetTextureIndices",s.uniqueId,this._morphTargetTextureIndexBuffers,o.numInfluencers,o._morphTargetTextureIndices),m.updateFloat3("morphTargetTextureInfo",o._textureVertexStride,o._textureWidth,o._textureHeight),m.updateFloat("morphTargetCount",o.numInfluencers),m.update()}f.setStorageBuffer("resultBuffer",i),f.setUniformBuffer("settings",m),f.dispatch(Math.ceil(n/256)),this._engine.flushFramebuffer()}}async fetchResultsForMeshListAsync(){return await new Promise(e=>{let t=[],i=0;for(let u=0;u<this._resultBuffers.length;u++){let o=this._resultBuffers[u].getBuffer();t.push(o),i+=o.capacity}let r=new Float32Array(i/Float32Array.BYTES_PER_ELEMENT),s=g.Zero(),n=g.Zero(),a={minimum:s,maximum:n};this._engine.readFromMultipleStorageBuffers(t,0,void 0,r,!0).then(()=>{let u=0;for(let o=0;o<this._resultBuffers.length;o++){for(let h=0;h<this._processedMeshes.length;h++){let f=this._processedMeshes[h];g.FromArrayToRef(r,u+h*8,s),g.FromArrayToRef(r,u+h*8+3,n),o>0&&(s.minimizeInPlace(f.getBoundingInfo().minimum),n.maximizeInPlace(f.getBoundingInfo().maximum)),f._refreshBoundingInfoDirect(a)}u+=8*this._processedMeshes.length}for(let o of this._resultBuffers)o.dispose();this._resultBuffers=[],this._uboIndex=0,e()})})}_disposeCache(e){for(let t in e)e[t].dispose()}_disposeForMeshList(){for(let e of this._resultBuffers)e.dispose();this._resultBuffers=[],this._processedMeshes=[],this._computeShaders=[],this._uniqueComputeShaders=new Set}dispose(){this._disposeCache(this._positionBuffers),this._positionBuffers={},this._disposeCache(this._indexBuffers),this._indexBuffers={},this._disposeCache(this._weightBuffers),this._weightBuffers={},this._disposeCache(this._morphTargetInfluenceBuffers),this._morphTargetInfluenceBuffers={},this._disposeCache(this._morphTargetTextureIndexBuffers),this._morphTargetTextureIndexBuffers={};for(let e of this._ubos)e.dispose();this._ubos=[],this._computeShadersCache={},this._engine=void 0,this._disposeForMeshList()}}});export{l as a,D as b,c,P as d,V as e,J as f};
